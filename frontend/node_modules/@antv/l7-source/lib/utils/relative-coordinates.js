var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/relative-coordinates.ts
var relative_coordinates_exports = {};
__export(relative_coordinates_exports, {
  calculateRelativeOrigin: () => calculateRelativeOrigin,
  convertToAbsoluteCoordinates: () => convertToAbsoluteCoordinates,
  convertToRelativeCoordinates: () => convertToRelativeCoordinates,
  processRelativeCoordinates: () => processRelativeCoordinates
});
module.exports = __toCommonJS(relative_coordinates_exports);
function calculateRelativeOrigin(dataArray) {
  let minLng = Infinity;
  let maxLng = -Infinity;
  let minLat = Infinity;
  let maxLat = -Infinity;
  dataArray.forEach((item) => {
    const coordinates = item.coordinates;
    if (!coordinates)
      return;
    const processCoordinates = (coords) => {
      if (typeof coords[0] === "number" && typeof coords[1] === "number") {
        const [lng, lat] = coords;
        minLng = Math.min(minLng, lng);
        maxLng = Math.max(maxLng, lng);
        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
      } else if (Array.isArray(coords[0])) {
        coords.forEach(processCoordinates);
      }
    };
    processCoordinates(coordinates);
  });
  const centerLng = (minLng + maxLng) / 2;
  const centerLat = (minLat + maxLat) / 2;
  return [centerLng, centerLat];
}
function convertToRelativeCoordinates(dataArray, relativeOrigin) {
  const [originLng, originLat] = relativeOrigin;
  return dataArray.map((item) => {
    if (!item.coordinates)
      return item;
    const convertCoordinates = (coords) => {
      if (typeof coords[0] === "number" && typeof coords[1] === "number") {
        const relativeLng = Number((coords[0] - originLng).toPrecision(15));
        const relativeLat = Number((coords[1] - originLat).toPrecision(15));
        return [relativeLng, relativeLat, ...coords.slice(2) || []];
      } else if (Array.isArray(coords[0])) {
        return coords.map(convertCoordinates);
      }
      return coords;
    };
    return __spreadProps(__spreadValues({}, item), {
      coordinates: convertCoordinates(item.coordinates)
    });
  });
}
function convertToAbsoluteCoordinates(dataArray, relativeOrigin) {
  const [originLng, originLat] = relativeOrigin;
  return dataArray.map((item) => {
    if (!item.coordinates)
      return item;
    const convertCoordinates = (coords) => {
      if (typeof coords[0] === "number" && typeof coords[1] === "number") {
        const absoluteLng = coords[0] + originLng;
        const absoluteLat = coords[1] + originLat;
        return [absoluteLng, absoluteLat, ...coords.slice(2) || []];
      } else if (Array.isArray(coords[0])) {
        return coords.map(convertCoordinates);
      }
      return coords;
    };
    return __spreadProps(__spreadValues({}, item), {
      coordinates: convertCoordinates(item.coordinates)
    });
  });
}
function processRelativeCoordinates(dataArray, options = {}) {
  const { enableRelativeCoordinates = false, relativeOrigin: customOrigin } = options;
  if (!enableRelativeCoordinates) {
    return {
      dataArray,
      relativeOrigin: [0, 0],
      originalExtent: [0, 0, 0, 0]
    };
  }
  let minLng = Infinity;
  let maxLng = -Infinity;
  let minLat = Infinity;
  let maxLat = -Infinity;
  dataArray.forEach((item) => {
    const coordinates = item.coordinates;
    if (!coordinates)
      return;
    const processCoordinates = (coords) => {
      if (typeof coords[0] === "number" && typeof coords[1] === "number") {
        const [lng, lat] = coords;
        minLng = Math.min(minLng, lng);
        maxLng = Math.max(maxLng, lng);
        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
      } else if (Array.isArray(coords[0])) {
        coords.forEach(processCoordinates);
      }
    };
    processCoordinates(coordinates);
  });
  const originalExtent = [minLng, minLat, maxLng, maxLat];
  const relativeOrigin = customOrigin || calculateRelativeOrigin(dataArray);
  const relativeDataArray = convertToRelativeCoordinates(dataArray, relativeOrigin);
  return {
    dataArray: relativeDataArray,
    relativeOrigin,
    originalExtent
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  calculateRelativeOrigin,
  convertToAbsoluteCoordinates,
  convertToRelativeCoordinates,
  processRelativeCoordinates
});
